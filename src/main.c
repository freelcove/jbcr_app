#include "globals.h"

int main()
{

	// 전역 변수 Initialization
	initGlobals();

	loadUserInfo();

	// 콘솔창 Initialization.
	InitScreen();

	// db를 저장할 questions[] 선언
	ObjectiveQuestion *objective_questions = malloc(sizeof(ObjectiveQuestion) * MAX_QUESTIONS);
	SubjectiveQuestion *subjective_questions = malloc(sizeof(SubjectiveQuestion) * MAX_QUESTIONS);

	// tsv 파일에서 데이터 불러와서 questions[] 배열에 저장
	readObjectiveQuestions(objective_questions);
	readSubjectiveQuestions(subjective_questions);

	// 히스토리를 저장할 queue 생성
	struct Queue *queue_objective = create_queue();
	struct Queue *queue_subjective = create_queue();

	readHistory(queue_objective, queue_subjective);

	// 만약 프로그램 첫 실행이라면 히스토리를 새로 채워 넣음.
	if (queue_objective->front == NULL)
	{
		for (int i = 0; i < num_objective_questions; i++)
		{
			enqueue(queue_objective, i);
		}
	}

	if (queue_subjective->front == NULL)
	{
		for (int i = 0; i < num_subjective_questions; i++)
		{
			enqueue(queue_subjective, i);
		}
	}

	while (1)
	{
		current_menu = 0;
		clearScreen();
		drawTitle();

		while (1)
		{
			draw_menu();
			key_pressed = getch();
			if (key_pressed == 'w' || key_pressed == 'W' || key_pressed == 72)
			{
				current_menu = (current_menu - 1 + 5) % 5;
			}
			else if (key_pressed == 's' || key_pressed == 'S' || key_pressed == 80)
			{
				current_menu = (current_menu + 1) % 5;
			}
			else if (key_pressed == '\r')
			{
				clearScreen();
				break;
			}
			else if (key_pressed == 27)
			{
				clearScreen();
				current_menu = 4;
				break;
			}
		}
		switch (current_menu)
		{

			// 메뉴 "객관식 문제"
		case 0:
		{
			all_process_objective(objective_questions, queue_objective);
		}
		break;

			// 메뉴 "주관식 문제"

		case 1:
			printf("주관식 문제\n\n\n");
			{
				int solved_questions = 0;

				while (1)
				{
					int id = queue_subjective->front->key;

					printf("%s\n", subjective_questions[id].definition);

					printf("\n정답을 입력하세요\n");
					char user_answer[MAX_LINE_LENGTH];
					scanf("%[^\n]%*c", user_answer);

					/*


			printf("\n정답을 입력하세요\n");
					char user_answer[MAX_LINE_LENGTH];
					fgets(user_answer, MAX_LINE_LENGTH, stdin);
					int len = strlen(user_answer);
					if (user_answer[len - 1] == '\n') {
						user_answer[len - 1] = '\0';
					}
					*/

					// subjective_questions, id
					if (match(user_answer, subjective_questions[id].name) == 0)
					{ // match 함수 활용
						printf("정답입니다.\n");
						enqueue(queue_subjective, queue_subjective->front->key);
						dequeue(queue_subjective);
					}

					else
					{
						printf("오답입니다.\n");
						insert_after_x(queue_subjective, queue_subjective->front->key, interval_failed_questions);
						dequeue(queue_subjective);
					}

					solved_questions++;
					printf("다음 문제로 넘어가시려면 엔터를 누르세요\n종료를 원하시면 x를 누르세요.\n");
					current_menu = 0;
					int swit = 0;
					while (1)
					{
						if (kbhit())
						{
							char input = getchar();
							if (input == 'x')
								swit = 1;
							break;
						}
					}
					if (swit == 1)
					{
						clearScreen();
						Percentage(solved_questions);
						break;
					}
					clearScreen();
				}
			}
			break;

			// 메뉴 "사용자"
		case 2:
			drawTitle();
			current_menu = 0;
			while (1)
			{
				drawUserOptions();
				key_pressed = getch();
				if (key_pressed == 27 || (key_pressed == '\r' && current_menu == 4))
				{
					break;
				};
				controlUserOptions();
			}
			break;

			// 메뉴 "옵션"
		case 3:
			drawTitle();
			current_menu = 0;
			while (1)
			{
				drawOptions();
				key_pressed = getch();
				if (key_pressed == 27 || (key_pressed == '\r' && current_menu == 4))
				{
					break;
				};
				controlOptions();
			}
			break;

		case 4:
			printf("프로그램 종료");

			// db_history.tsv에 history를 저장
			writeHistory(queue_objective, queue_subjective);

			WriteUserInfo();

			// 동적할당한 메모리 해제
			free(objective_questions);
			free(subjective_questions);

			return 0;
		default:
			break;
		}
	}
	return 0;
}
